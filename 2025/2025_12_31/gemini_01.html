<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breath & Meditation Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        :root { --primary: #4a90e2; --bg: #f5f7fa; --panel: #ffffff; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: #333; max-width: 900px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; color: #2c3e50; }
        
        .controls { position: sticky; top: 0; background: var(--bg); padding: 15px 0; z-index: 100; display: flex; gap: 10px; align-items: center; border-bottom: 1px solid #ddd; }
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 1rem; transition: background 0.2s; }
        button:hover { background: #357abd; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.record { background: #e74c3c; }
        
        .progress-container { flex-grow: 1; height: 10px; background: #ddd; border-radius: 5px; position: relative; cursor: pointer; }
        .progress-bar { height: 100%; background: var(--primary); width: 0%; border-radius: 5px; }
        .time-display { font-family: monospace; font-size: 1.1rem; min-width: 100px; text-align: right; }

        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .section { background: var(--panel); padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h2 { margin-top: 0; font-size: 1.2rem; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        
        .drop-zone { border: 2px dashed #ccc; padding: 20px; text-align: center; margin-bottom: 15px; border-radius: 8px; transition: 0.2s; position: relative; }
        .drop-zone.active { border-color: var(--primary); background: #eef5ff; }
        .drop-zone.loaded { border-style: solid; border-color: #2ecc71; background: #f0fff4; }
        .drop-zone p { margin: 0; pointer-events: none; color: #666; font-size: 0.9rem; }
        .remove-btn { position: absolute; top: 5px; right: 5px; background: none; border: none; color: #e74c3c; cursor: pointer; font-size: 0.8rem; display: none; padding: 2px 5px; }
        .drop-zone.loaded .remove-btn { display: block; }
        
        .info { font-size: 0.85rem; color: #666; margin-top: 5px; }

        @media (max-width: 600px) { .grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

    <h1>Guided Breath & Meditation Builder</h1>

    <div class="controls">
        <button id="btnPlay">▶ Play Preview</button>
        <button id="btnStop">■ Stop</button>
        <div class="progress-container" id="progressBarContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="time-display" id="timeDisplay">00:00</div>
        <button id="btnSave" class="record">Save as MP3</button>
    </div>
    <div id="status" style="text-align: center; color: #666; font-size: 0.9rem; margin-top:5px; height: 1.2em;"></div>

    <div class="grid">
        <div class="section">
            <h2>1. Breathing Sounds (Rounds 1-3)</h2>
            <div class="info">Replaces the default "Tick/Tock" metronome.</div>
            <br>
            <div class="drop-zone" id="dz-inhale" data-slot="inhale">
                <p>Drop <b>Inhale</b> Sound Here</p>
                <button class="remove-btn">x</button>
            </div>
            <div class="drop-zone" id="dz-exhale" data-slot="exhale">
                <p>Drop <b>Exhale</b> Sound Here</p>
                <button class="remove-btn">x</button>
            </div>
            <div class="drop-zone" id="dz-deep-in" data-slot="deepIn">
                <p>Drop <b>Deep Inhale</b> (Recovery start)</p>
                <button class="remove-btn">x</button>
            </div>
            <div class="drop-zone" id="dz-deep-out" data-slot="deepOut">
                <p>Drop <b>Deep Exhale</b> (Recovery end)</p>
                <button class="remove-btn">x</button>
            </div>
        </div>

        <div class="section">
            <h2>2. Atmosphere & Meditation</h2>
            <div class="drop-zone" id="dz-hold" data-slot="hold">
                <p>Drop <b>Breath Hold</b> Background<br>(Loops during hold phases)</p>
                <button class="remove-btn">x</button>
            </div>
            <div class="drop-zone" id="dz-voice" data-slot="voice">
                <p>Drop <b>Meditation Voice</b><br>(Plays at start of free meditation)</p>
                <button class="remove-btn">x</button>
            </div>
            <div class="info">
                The "Free Meditation" (last ~10 mins) generates an ambient synth progression through the Circle of Fifths automatically. Your voice clip will overlay this music.
            </div>
        </div>
    </div>

<script>
/**
 * CONFIGURATION & STATE
 */
const CONFIG = {
    introDuration: 20,
    breathsPerRound: 30,
    breathInDuration: 1.5,
    breathOutDuration: 1.5, // Total cycle 3s
    recoveryHoldDuration: 15,
    roundHolds: [60, 90, 90], // Seconds for round 1, 2, 3
    totalDuration: 20 * 60 // 20 minutes
};

// Global State
let audioContext = null;
let masterGain = null;
let playbackSourceNodes = []; // Track nodes to stop them
let isPlaying = false;
let startTime = 0;
let playbackPausedAt = 0;

// User uploaded buffers
const userBuffers = {
    inhale: null,
    exhale: null,
    deepIn: null,
    deepOut: null,
    hold: null,
    voice: null
};

/**
 * UI & DRAG-DROP HANDLERS
 */
const dropZones = document.querySelectorAll('.drop-zone');
const statusEl = document.getElementById('status');

// Setup Drop Zones
dropZones.forEach(zone => {
    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('active'); });
    zone.addEventListener('dragleave', e => { e.preventDefault(); zone.classList.remove('active'); });
    zone.addEventListener('drop', async e => {
        e.preventDefault();
        zone.classList.remove('active');
        const file = e.dataTransfer.files[0];
        if(file) {
            handleFileUpload(file, zone.dataset.slot, zone);
        }
    });
    
    // Remove button
    zone.querySelector('.remove-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        userBuffers[zone.dataset.slot] = null;
        zone.classList.remove('loaded');
        zone.querySelector('p').innerHTML = zone.querySelector('p').getAttribute('data-original') || zone.querySelector('p').innerHTML;
    });
    
    // Save original text for restore
    const p = zone.querySelector('p');
    p.setAttribute('data-original', p.innerHTML);
});

async function handleFileUpload(file, slot, zoneElement) {
    statusEl.innerText = "Decoding audio...";
    try {
        const arrayBuffer = await file.arrayBuffer();
        // We use a temporary context to decode, so we don't need the main one running yet
        const tempCtx = new AudioContext(); 
        const audioBuffer = await tempCtx.decodeAudioData(arrayBuffer);
        userBuffers[slot] = audioBuffer;
        
        zoneElement.classList.add('loaded');
        zoneElement.querySelector('p').innerHTML = `<b>${file.name}</b> loaded`;
        statusEl.innerText = "";
    } catch(e) {
        console.error(e);
        statusEl.innerText = "Error decoding audio file.";
    }
}

/**
 * AUDIO GENERATION LOGIC
 * This function schedules all events on a given AudioContext (Realtime or Offline)
 */
function scheduleAudio(ctx, destination) {
    const t0 = ctx.currentTime;
    let timeCursor = t0 + CONFIG.introDuration; // Skip intro silence/intro buffer time

    // --- ROUNDS 1, 2, 3 ---
    CONFIG.roundHolds.forEach((holdDuration, index) => {
        // 1. Rhythmic Breathing
        for (let i = 0; i < CONFIG.breathsPerRound; i++) {
            const isLastBreath = i === CONFIG.breathsPerRound - 1;
            
            // Inhale
            if (userBuffers.inhale) {
                playBuffer(ctx, destination, userBuffers.inhale, timeCursor);
            } else {
                playSynthClick(ctx, destination, timeCursor, 800, 0.05); // High tick
            }
            timeCursor += CONFIG.breathInDuration;

            // Exhale
            if (isLastBreath) {
                // Last exhale is special (usually longer or deeper)
                 if (userBuffers.deepOut) {
                    playBuffer(ctx, destination, userBuffers.deepOut, timeCursor);
                } else if (userBuffers.exhale) {
                    playBuffer(ctx, destination, userBuffers.exhale, timeCursor);
                } else {
                    playSynthClick(ctx, destination, timeCursor, 400, 0.2); // Longer low tock
                }
            } else {
                if (userBuffers.exhale) {
                    playBuffer(ctx, destination, userBuffers.exhale, timeCursor);
                } else {
                    playSynthClick(ctx, destination, timeCursor, 400, 0.05); // Low tock
                }
            }
            timeCursor += CONFIG.breathOutDuration;
        }

        // 2. Breath Hold
        const holdStart = timeCursor;
        const holdEnd = timeCursor + holdDuration;
        
        if (userBuffers.hold) {
            // Loop the hold sound to fill duration
            let loopCursor = holdStart;
            while(loopCursor < holdEnd) {
                let dur = userBuffers.hold.duration;
                // Crop last loop if needed
                let playDur = (loopCursor + dur > holdEnd) ? holdEnd - loopCursor : dur;
                playBuffer(ctx, destination, userBuffers.hold, loopCursor, playDur);
                loopCursor += dur;
            }
        } else {
            // Synth Hold Sound: Subtle ticking clock or silence (We'll do a soft pink noise bed)
            playNoise(ctx, destination, holdStart, holdDuration);
        }
        timeCursor += holdDuration;

        // 3. Recovery (Deep Inhale Hold)
        if (userBuffers.deepIn) {
            playBuffer(ctx, destination, userBuffers.deepIn, timeCursor);
        } else {
            playSynthTone(ctx, destination, timeCursor, 2, 220); // Synth cue
        }
        
        // 15 seconds hold logic is implicit in timing, we just mark the end
        timeCursor += CONFIG.recoveryHoldDuration;
        
        if (userBuffers.deepOut) {
            playBuffer(ctx, destination, userBuffers.deepOut, timeCursor);
        } else {
             playSynthClick(ctx, destination, timeCursor, 300, 0.5); // Release sound
        }
        // Small gap before next round
        timeCursor += 2; 
    });

    // --- FREE MEDITATION (CIRCLE OF FIFTHS) ---
    const meditationStart = timeCursor;
    const remainingTime = CONFIG.totalDuration - (meditationStart - t0);
    
    // Voice Overlay
    if (userBuffers.voice) {
        playBuffer(ctx, destination, userBuffers.voice, meditationStart);
    }

    // Ambient Music Generation
    if (remainingTime > 0) {
        generateCircleOfFifths(ctx, destination, meditationStart, remainingTime);
    }
}

/**
 * SYNTHESIS HELPERS
 */
function playBuffer(ctx, dest, buffer, time, duration = null) {
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(dest);
    source.start(time);
    if(duration) source.stop(time + duration);
    if(ctx instanceof AudioContext) playbackSourceNodes.push(source); // Track for stopping preview
}

function playSynthClick(ctx, dest, time, freq, dur) {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = freq;
    osc.type = 'sine';
    
    gain.gain.setValueAtTime(0.5, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
    
    osc.connect(gain);
    gain.connect(dest);
    
    osc.start(time);
    osc.stop(time + dur);
    if(ctx instanceof AudioContext) playbackSourceNodes.push(osc);
}

function playSynthTone(ctx, dest, time, dur, freq) {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = freq;
    
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.3, time + 0.1);
    gain.gain.linearRampToValueAtTime(0, time + dur);
    
    osc.connect(gain);
    gain.connect(dest);
    osc.start(time);
    osc.stop(time + dur);
    if(ctx instanceof AudioContext) playbackSourceNodes.push(osc);
}

function playNoise(ctx, dest, time, dur) {
    // Simple pinkish noise for hold
    const bufferSize = ctx.sampleRate * 2; // 2 seconds buffer
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.05;
    }
    
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    noise.loop = true;
    
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.1, time + 1); // Fade in
    gain.gain.setValueAtTime(0.1, time + dur - 1);
    gain.gain.linearRampToValueAtTime(0, time + dur); // Fade out

    noise.connect(gain);
    gain.connect(dest);
    noise.start(time);
    noise.stop(time + dur);
    if(ctx instanceof AudioContext) playbackSourceNodes.push(noise);
}

function generateCircleOfFifths(ctx, dest, startTime, totalDuration) {
    // Circle of 5ths starting at C: C, G, D, A, E, B, F#, Db, Ab, Eb, Bb, F
    // Frequencies (Octave 3/4 mix)
    const baseFreqs = [261.63, 392.00, 293.66, 440.00, 329.63, 493.88, 369.99, 277.18, 415.30, 311.13, 466.16, 349.23];
    
    const stepDuration = totalDuration / 12;

    baseFreqs.forEach((freq, i) => {
        const stepStart = startTime + (i * stepDuration);
        const overlap = 5; // Overlap seconds for smooth transition
        
        // Create a rich pad using 2 oscillators slightly detuned
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        osc1.type = 'triangle';
        osc2.type = 'sine';
        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 1.01; // Detune
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, stepStart);
        // Fade In
        gain.gain.linearRampToValueAtTime(0.1, stepStart + (stepDuration*0.2));
        // Fade Out
        gain.gain.linearRampToValueAtTime(0, stepStart + stepDuration + overlap);
        
        osc1.connect(gain);
        osc2.connect(gain);
        gain.connect(dest);
        
        osc1.start(stepStart);
        osc1.stop(stepStart + stepDuration + overlap);
        osc2.start(stepStart);
        osc2.stop(stepStart + stepDuration + overlap);
        
        if(ctx instanceof AudioContext) {
            playbackSourceNodes.push(osc1);
            playbackSourceNodes.push(osc2);
        }
    });
}

/**
 * PLAYER CONTROLS
 */
const btnPlay = document.getElementById('btnPlay');
const btnStop = document.getElementById('btnStop');
const btnSave = document.getElementById('btnSave');
const progressBar = document.getElementById('progressBar');
const timeDisplay = document.getElementById('timeDisplay');
let animationFrame;

btnPlay.addEventListener('click', () => {
    if(isPlaying) return;
    
    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioContext.createGain();
    masterGain.connect(audioContext.destination);
    
    // Reset if finished
    if(audioContext.state === 'suspended') audioContext.resume();

    startTime = audioContext.currentTime;
    playbackSourceNodes = [];
    
    scheduleAudio(audioContext, masterGain);
    
    isPlaying = true;
    updateUI();
});

btnStop.addEventListener('click', () => {
    if(audioContext) {
        // Stop all tracked nodes
        playbackSourceNodes.forEach(node => {
            try { node.stop(); } catch(e){}
        });
        audioContext.close();
        audioContext = null;
    }
    isPlaying = false;
    cancelAnimationFrame(animationFrame);
    progressBar.style.width = '0%';
    timeDisplay.innerText = "00:00";
});

function updateUI() {
    if(!isPlaying || !audioContext) return;
    
    const elapsed = audioContext.currentTime - startTime;
    const progress = (elapsed / CONFIG.totalDuration) * 100;
    
    progressBar.style.width = Math.min(progress, 100) + '%';
    
    const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
    const s = Math.floor(elapsed % 60).toString().padStart(2, '0');
    timeDisplay.innerText = `${m}:${s}`;
    
    if(elapsed < CONFIG.totalDuration) {
        animationFrame = requestAnimationFrame(updateUI);
    } else {
        isPlaying = false;
    }
}

/**
 * SAVE TO MP3
 */
btnSave.addEventListener('click', async () => {
    btnSave.disabled = true;
    btnSave.innerText = "Rendering...";
    statusEl.innerText = "Generating audio offline (this is fast)...";

    // 1. Render Offline
    const offlineCtx = new OfflineAudioContext(2, 44100 * CONFIG.totalDuration, 44100);
    scheduleAudio(offlineCtx, offlineCtx.destination);
    
    const renderedBuffer = await offlineCtx.startRendering();
    
    statusEl.innerText = "Encoding MP3...";
    
    // 2. Encode to MP3 using lamejs
    // We need to do this in chunks to avoid blocking UI too much, 
    // but for simplicity here we do it synchronously or via timeout
    setTimeout(() => {
        const mp3Blob = bufferToMp3(renderedBuffer);
        
        // 3. Download
        const url = URL.createObjectURL(mp3Blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'meditation-session.mp3';
        a.click();
        
        btnSave.disabled = false;
        btnSave.innerText = "Save as MP3";
        statusEl.innerText = "Done!";
    }, 100);
});

function bufferToMp3(buffer) {
    const channels = 2; // Stereo
    const sampleRate = buffer.sampleRate;
    const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 128); // 128kbps
    
    const left = buffer.getChannelData(0);
    const right = buffer.getChannelData(1);
    
    // lamejs requires integer input
    const sampleBlockSize = 1152;
    const mp3Data = [];
    
    for (let i = 0; i < left.length; i += sampleBlockSize) {
        const leftChunk = left.subarray(i, i + sampleBlockSize);
        const rightChunk = right.subarray(i, i + sampleBlockSize);
        
        const leftInt = new Int16Array(leftChunk.length);
        const rightInt = new Int16Array(rightChunk.length);
        
        // Convert float to int
        for (let j = 0; j < leftChunk.length; j++) {
            leftInt[j] = leftChunk[j] * 0x7FFF;
            rightInt[j] = rightChunk[j] * 0x7FFF;
        }
        
        const mp3buf = mp3encoder.encodeBuffer(leftInt, rightInt);
        if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
        }
    }
    
    const endBuf = mp3encoder.flush();
    if (endBuf.length > 0) {
        mp3Data.push(endBuf);
    }
    
    return new Blob(mp3Data, { type: 'audio/mp3' });
}
</script>

</body>
</html>