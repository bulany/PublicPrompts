<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Breathwork Conductor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #2a2a2a;
            --text: #e0e0e0;
            --accent: #4a90e2;
            --breath-color: #2ecc71;
            --hold-color: #e74c3c;
            --meditate-color: #9b59b6;
            --beat-color: #f1c40f;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* --- TOP TRANSPORT BAR --- */
        .transport {
            background: var(--panel);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 24px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            min-width: 100px;
        }
        .btn:hover { filter: brightness(1.1); }
        .btn.stop { background: #c0392b; }

        .time-display {
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            font-weight: bold;
            margin-left: auto;
            color: var(--accent);
        }

        /* Global Timeline */
        .timeline-container {
            position: relative;
            height: 30px;
            background: #444;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
        }

        .timeline-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #6dd5ed);
            width: 0%;
            pointer-events: none;
            transition: width 0.1s linear;
        }

        /* Markers on the timeline */
        .marker {
            position: absolute;
            top: 0; bottom: 0;
            width: 1px;
            background: rgba(255,255,255,0.3);
            pointer-events: none;
        }
        .marker-label {
            position: absolute;
            top: 2px;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
            margin-left: 4px;
        }

        /* --- MAIN PERFORMANCE AREA --- */
        .main-stage {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Section Info */
        .section-header {
            position: absolute;
            top: 20px;
            text-align: center;
            width: 100%;
        }
        .current-section-title {
            font-size: 2.5rem;
            font-weight: 300;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .section-timer {
            font-size: 1.5rem;
            color: #888;
            margin-top: 5px;
            font-family: monospace;
        }

        /* Visualizers */
        .visualizer-container {
            position: relative;
            width: 400px;
            height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Breathing Circle */
        .breath-circle {
            width: 200px;
            height: 200px;
            background: var(--breath-color);
            border-radius: 50%;
            opacity: 0.8;
            transform: scale(1);
            /* Transitions handled by JS for precision */
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 50px rgba(46, 204, 113, 0.3);
        }

        .breath-text {
            font-size: 2rem;
            color: #000;
            font-weight: bold;
        }

        /* Hold Bar */
        .hold-display {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 80%;
        }
        .hold-bar-bg {
            width: 100%;
            height: 20px;
            background: #444;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px;
        }
        .hold-bar-fill {
            height: 100%;
            background: var(--hold-color);
            width: 100%;
        }

        /* Meditation Keys */
        .meditation-display {
            display: none;
            text-align: center;
        }
        .key-badge {
            font-size: 4rem;
            font-weight: bold;
            color: var(--meditate-color);
            border: 4px solid var(--meditate-color);
            padding: 20px 40px;
            border-radius: 10px;
            margin-bottom: 20px;
            background: rgba(0,0,0,0.3);
        }
        .progress-dots {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .dot {
            width: 12px;
            height: 12px;
            background: #444;
            border-radius: 50%;
        }
        .dot.active { background: var(--meditate-color); box-shadow: 0 0 10px var(--meditate-color); }

        /* Metronome Flash */
        .beat-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #333;
        }
        .beat-indicator.flash { background: var(--beat-color); box-shadow: 0 0 15px var(--beat-color); }

        /* --- FOOTER: CUSTOM AUDIO --- */
        .audio-drawer {
            background: var(--panel);
            padding: 15px;
            border-top: 1px solid #444;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .drop-zone {
            border: 2px dashed #555;
            padding: 10px;
            text-align: center;
            border-radius: 6px;
            color: #888;
            font-size: 0.9rem;
            transition: 0.2s;
        }
        .drop-zone.active { border-color: var(--accent); background: rgba(74, 144, 226, 0.1); }
        .drop-zone.loaded { border-style: solid; border-color: var(--breath-color); background: rgba(46, 204, 113, 0.1); color: var(--breath-color); }

    </style>
</head>
<body>

    <div class="transport">
        <div class="controls-row">
            <button class="btn" id="btnStart">Start</button>
            <button class="btn stop" id="btnStop">Stop / Reset</button>
            <div style="flex-grow:1"></div>
            <div class="time-display" id="globalTime">00:00</div>
        </div>
        
        <div class="timeline-container" id="timeline">
            <div class="timeline-fill" id="timelineFill"></div>
            <div id="markersContainer"></div>
        </div>
    </div>

    <div class="main-stage">
        
        <div class="beat-indicator" id="beatLight"></div>

        <div class="section-header">
            <h1 class="current-section-title" id="sectionTitle">Ready</h1>
            <div class="section-timer" id="sectionTimer">--:--</div>
        </div>

        <div class="visualizer-container">
            <div id="visBreath" class="breath-circle" style="display:none">
                <div class="breath-text" id="breathCount">1</div>
            </div>

            <div id="visHold" class="hold-display">
                <h2 style="margin:0; font-size: 2rem;">HOLD</h2>
                <div class="hold-bar-bg">
                    <div class="hold-bar-fill" id="holdBar"></div>
                </div>
            </div>

            <div id="visMeditate" class="meditation-display">
                <div class="key-badge" id="keyBadge">C</div>
                <div style="font-size: 1.2rem; margin-bottom: 10px; color: #aaa;">Circle of Fifths Progression</div>
                <div class="progress-dots" id="keyDots">
                    </div>
            </div>
        </div>

    </div>

    <div class="audio-drawer">
        <div class="drop-zone" id="dz-inhale" data-slot="inhale">
            Drop Custom <b>Inhale</b> Sound (WAV/MP3)
        </div>
        <div class="drop-zone" id="dz-exhale" data-slot="exhale">
            Drop Custom <b>Exhale</b> Sound (WAV/MP3)
        </div>
    </div>

<script>
/**
 * 1. CONFIGURATION
 */
const CONFIG = {
    introBeats: 4,      // 4 beats count-in
    bpm: 60,            // 1 beat per second
    breathsPerRound: 30,
    breathInTime: 1.5,
    breathOutTime: 1.5, // 3s total cycle
    roundHolds: [60, 90, 90], // Seconds
    recoveryHold: 15,
    totalTargetDuration: 20 * 60 // 20 mins
};

// Calculated Constants
const breathCycleDuration = CONFIG.breathInTime + CONFIG.breathOutTime;
const breathingPhaseDuration = CONFIG.breathsPerRound * breathCycleDuration;

/**
 * 2. STRUCTURE DEFINITION
 * We build an array of "Regions" describing the session.
 */
let timelineRegions = [];

function buildTimeline() {
    let currentTime = 0;
    
    // Helper to add region
    const add = (type, duration, label, roundIndex = 0) => {
        timelineRegions.push({
            type: type, // 'intro', 'breath', 'hold', 'recovery', 'meditate'
            start: currentTime,
            end: currentTime + duration,
            duration: duration,
            label: label,
            round: roundIndex
        });
        currentTime += duration;
    };

    // 0. Intro (4 beats = 4 seconds at 60bpm)
    add('intro', 4, 'Intro');

    // Rounds 1, 2, 3
    CONFIG.roundHolds.forEach((holdTime, i) => {
        let r = i + 1;
        add('breath', breathingPhaseDuration, `Round ${r}: Breathe`, r);
        add('hold', holdTime, `Round ${r}: Hold`, r);
        add('recovery', CONFIG.recoveryHold, `Round ${r}: Recovery`, r);
    });

    // Free Meditation
    // Fills whatever is left to reach totalTargetDuration
    const timeLeft = CONFIG.totalTargetDuration - currentTime;
    if (timeLeft > 0) {
        add('meditate', timeLeft, 'Free Meditation');
    }
}

buildTimeline();

/**
 * 3. TONE.JS SETUP
 */
let isRunning = false;
let userBuffers = { inhale: null, exhale: null };
let metronomeSynth, subSynth;
let players = {};

async function initAudio() {
    await Tone.start();
    
    // Basic Metronome Click
    metronomeSynth = new Tone.MembraneSynth({
        pitchDecay: 0.008,
        octaves: 2,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    metronomeSynth.volume.value = -10; // slightly quieter

    // Sub-beat (very faint)
    subSynth = new Tone.MembraneSynth().toDestination();
    subSynth.volume.value = -25; 

    // Custom Sample Players
    players.inhale = new Tone.Player().toDestination();
    players.exhale = new Tone.Player().toDestination();

    // Schedule the Metronome Loop (Runs forever, we manage logic inside)
    Tone.Transport.bpm.value = CONFIG.bpm;
    
    // Main Beat (Every Quarter Note)
    Tone.Transport.scheduleRepeat((time) => {
        // Visual Flash
        Tone.Draw.schedule(() => flashBeat(), time);
        
        // Audio Click
        metronomeSynth.triggerAttackRelease("C5", "32n", time);
    }, "4n");

    // Off Beat (Every Eighth Note, offset by eighth)
    Tone.Transport.scheduleRepeat((time) => {
        subSynth.triggerAttackRelease("C2", "32n", time);
    }, "4n", "8n");
}

/**
 * 4. RENDER LOOP (The Brain)
 * We use requestAnimationFrame to check Tone.Transport.seconds
 * and update the UI / trigger custom logic.
 */
function updateLoop() {
    if (!isRunning) return;
    
    requestAnimationFrame(updateLoop);

    const time = Tone.Transport.seconds;
    
    // Find current region
    const region = timelineRegions.find(r => time >= r.start && time < r.end);
    
    if (!region) {
        // End of session
        if (time > timelineRegions[timelineRegions.length-1].end) {
            stopSession();
        }
        return;
    }

    const timeInRegion = time - region.start;
    
    updateUI(region, timeInRegion, time);
    updateAudioLogic(region, timeInRegion, time);
}

/**
 * 5. UI UPDATES
 */
const ui = {
    globalTime: document.getElementById('globalTime'),
    timelineFill: document.getElementById('timelineFill'),
    sectionTitle: document.getElementById('sectionTitle'),
    sectionTimer: document.getElementById('sectionTimer'),
    beatLight: document.getElementById('beatLight'),
    // Visualizers
    visBreath: document.getElementById('visBreath'),
    breathCount: document.getElementById('breathCount'),
    visHold: document.getElementById('visHold'),
    holdBar: document.getElementById('holdBar'),
    visMeditate: document.getElementById('visMeditate'),
    keyBadge: document.getElementById('keyBadge'),
    keyDots: document.getElementById('keyDots')
};

function formatTime(s) {
    const m = Math.floor(s / 60).toString().padStart(2, '0');
    const sec = Math.floor(s % 60).toString().padStart(2, '0');
    return `${m}:${sec}`;
}

function updateUI(region, regionTime, globalTime) {
    // Top Bar
    ui.globalTime.innerText = formatTime(globalTime);
    const progressPct = (globalTime / CONFIG.totalTargetDuration) * 100;
    ui.timelineFill.style.width = `${progressPct}%`;

    // Section Info
    ui.sectionTitle.innerText = region.label;
    ui.sectionTimer.innerText = `${formatTime(regionTime)} / ${formatTime(region.duration)}`;

    // Reset Visuals
    ui.visBreath.style.display = 'none';
    ui.visHold.style.display = 'none';
    ui.visMeditate.style.display = 'none';

    // -- BREATHING VISUALS --
    if (region.type === 'breath') {
        ui.visBreath.style.display = 'flex';
        
        // Calculate breath cycle info
        // Cycle is 3s (1.5 in, 1.5 out)
        const cycleDur = CONFIG.breathInTime + CONFIG.breathOutTime;
        const currentBreathIndex = Math.floor(regionTime / cycleDur);
        const timeInCycle = regionTime % cycleDur;
        
        ui.breathCount.innerText = `${currentBreathIndex + 1} / ${CONFIG.breathsPerRound}`;
        
        // Breathing Animation (Sine wave)
        // Map 0 -> 1.5 (In) and 1.5 -> 3.0 (Out)
        let scale = 1;
        if (timeInCycle < CONFIG.breathInTime) {
            // Inhale: 1 -> 1.5
            const p = timeInCycle / CONFIG.breathInTime;
            // Easing for smoother feel
            scale = 1 + (0.5 * Math.sin(p * Math.PI / 2)); 
        } else {
            // Exhale: 1.5 -> 1
            const p = (timeInCycle - CONFIG.breathInTime) / CONFIG.breathOutTime;
            scale = 1.5 - (0.5 * Math.sin(p * Math.PI / 2));
        }
        ui.visBreath.style.transform = `scale(${scale})`;
    } 
    
    // -- HOLD / RECOVERY VISUALS --
    else if (region.type === 'hold' || region.type === 'recovery' || region.type === 'intro') {
        ui.visHold.style.display = 'flex';
        ui.visHold.querySelector('h2').innerText = region.type === 'intro' ? "PREPARE" : (region.type === 'recovery' ? "RECOVER (IN & HOLD)" : "HOLD BREATH");
        
        const pctLeft = 100 - ((regionTime / region.duration) * 100);
        ui.holdBar.style.width = `${pctLeft}%`;
    }

    // -- MEDITATION VISUALS --
    else if (region.type === 'meditate') {
        ui.visMeditate.style.display = 'block';
        
        // Divide remaining time into 12 segments
        const segDuration = region.duration / 12;
        const currentSeg = Math.min(11, Math.floor(regionTime / segDuration));
        
        // Circle of Fifths: C G D A E B Gb Db Ab Eb Bb F
        const keys = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'];
        
        ui.keyBadge.innerText = keys[currentSeg];
        ui.keyBadge.style.borderColor = `hsl(${currentSeg * 30}, 70%, 60%)`;
        ui.keyBadge.style.color = `hsl(${currentSeg * 30}, 70%, 60%)`;

        // Render dots
        ui.keyDots.innerHTML = '';
        for(let i=0; i<12; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot ' + (i === currentSeg ? 'active' : '');
            ui.keyDots.appendChild(dot);
        }
    }
}

function flashBeat() {
    ui.beatLight.classList.add('flash');
    setTimeout(() => ui.beatLight.classList.remove('flash'), 100);
}

/**
 * 6. AUDIO LOGIC (Triggering Samples)
 * Tone.js handles the metronome. We handle sample triggering manually here
 * to keep it synced with the visual state machine.
 */
let lastBreathPhase = null; // 'in' or 'out'

function updateAudioLogic(region, regionTime, globalTime) {
    if (region.type !== 'breath') return;

    const cycleDur = CONFIG.breathInTime + CONFIG.breathOutTime;
    const timeInCycle = regionTime % cycleDur;
    
    // Determine phase
    const currentPhase = (timeInCycle < CONFIG.breathInTime) ? 'in' : 'out';

    // Detect phase change to trigger sound once
    if (currentPhase !== lastBreathPhase) {
        if (currentPhase === 'in' && userBuffers.inhale) {
            players.inhale.start();
        } else if (currentPhase === 'out' && userBuffers.exhale) {
            players.exhale.start();
        }
        lastBreathPhase = currentPhase;
    }
}


/**
 * 7. INTERACTION & INITIALIZATION
 */
const btnStart = document.getElementById('btnStart');
const btnStop = document.getElementById('btnStop');
const timelineEl = document.getElementById('timeline');

// Setup Markers on Timeline
function renderMarkers() {
    const container = document.getElementById('markersContainer');
    container.innerHTML = '';
    const total = CONFIG.totalTargetDuration;
    
    timelineRegions.forEach(r => {
        const div = document.createElement('div');
        div.className = 'marker';
        div.style.left = (r.start / total * 100) + '%';
        container.appendChild(div);

        // Add Label if it's big enough
        if(r.duration > 30) {
            const label = document.createElement('div');
            label.className = 'marker-label';
            label.innerText = r.type.toUpperCase();
            label.style.left = (r.start / total * 100) + '%';
            container.appendChild(label);
        }
    });
}
renderMarkers();

btnStart.addEventListener('click', async () => {
    if (Tone.context.state !== 'running') await Tone.start();
    
    if (!isRunning) {
        initAudio().then(() => {
            Tone.Transport.start();
            isRunning = true;
            btnStart.innerText = "Pause";
            updateLoop();
        });
    } else {
        // Toggle Pause
        if (Tone.Transport.state === 'started') {
            Tone.Transport.pause();
            btnStart.innerText = "Resume";
        } else {
            Tone.Transport.start();
            btnStart.innerText = "Pause";
        }
    }
});

btnStop.addEventListener('click', () => {
    Tone.Transport.stop();
    Tone.Transport.seconds = 0; // Reset
    isRunning = false;
    btnStart.innerText = "Start";
    
    // Reset UI
    ui.timelineFill.style.width = '0%';
    ui.globalTime.innerText = "00:00";
    ui.sectionTitle.innerText = "Ready";
});

// Scrubbing
timelineEl.addEventListener('click', (e) => {
    if (!isRunning && Tone.context.state !== 'running') return; // Ignore if not started at least once
    
    const rect = timelineEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const pct = x / rect.width;
    const newTime = pct * CONFIG.totalTargetDuration;
    
    Tone.Transport.seconds = newTime;
    
    // If we scrub while paused, update UI once manually
    if (Tone.Transport.state !== 'started') {
        const region = timelineRegions.find(r => newTime >= r.start && newTime < r.end);
        if(region) {
            const timeInRegion = newTime - region.start;
            updateUI(region, timeInRegion, newTime);
        }
    }
});

// Drag & Drop Handling
['inhale', 'exhale'].forEach(slot => {
    const zone = document.getElementById(`dz-${slot}`);
    
    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('active'); });
    zone.addEventListener('dragleave', e => { e.preventDefault(); zone.classList.remove('active'); });
    
    zone.addEventListener('drop', async e => {
        e.preventDefault();
        zone.classList.remove('active');
        const file = e.dataTransfer.files[0];
        if(!file) return;

        // Load into Tone.js buffer
        const url = URL.createObjectURL(file);
        const buffer = new Tone.ToneAudioBuffer(url, () => {
            userBuffers[slot] = buffer;
            players[slot].buffer = buffer;
            zone.classList.add('loaded');
            zone.innerHTML = `<b>${file.name}</b> loaded`;
        });
    });
});

</script>
</body>
</html>